<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: kodt.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: kodt.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
(function ( factory ) {
    "use strict";

    if ("function" === typeof define &amp;&amp; define.amd) {
        define(["knockout", "jquery", "datatables"], factory);
    } else if ("undefined" !== typeof module) {
        module.exports = factory(
            require("knockout"),
            require("jquery"),
            require("datatables")
        );
    } else {
        if (!(window.ko &amp;&amp; window.$)) {
            throw new Error("grid: not supported");
        }

        factory(window.ko, window.$);
    }

})(function ( ko, $ ) {
    "use strict";

    /** @namespace ko */

    // ========== HELPERS ==========

    var pid_generator
    ,   pid_for_column
    ,   make_element
    ,   make_binding
    ,   unwrap_template
    ;

    /**
     * creates a pid generator with the given prefix
     * @private
     * @param {String} prefix value to return before the pid
     * @return {String} prefix followed by next pid
     */
    pid_generator = function ( prefix ) {
        var id = 0;
        prefix = prefix || ""; // -jshint won"t allow expression

        return function ( ) {
            return prefix + id++;
        };
    };

    /**
     * creates a string form of an element
     * @private
     * @param {String} name what element to create
     * @param {Object} [attrs] attributes to place on the element
     * @param {String|Boolean} [content] what to place in the item
     *  if content is false, item will self close
     * @return {String} constructed element
     */
    make_element = function ( name, attrs, content ) {
        var attr, elem = "&lt;" + name;
        for (attr in attrs) {
            elem += " " + attr + "=\"" + attrs[attr] + "\"";
        }
        if (content === false) {
            elem += "/>";
        } else {
            elem += ">" + (content || "") + "&lt;/" + name + ">";
        }
        return elem;
    };

    /**
     * formats json into ko bindings
     * @private
     * @param {Object} attrs attributes to bind
     * @return {Object} binding as string in object with data-bind
     */
    make_binding = function ( attrs ) {
        var attr, elem, elems = [ ];

        for (attr in attrs) {
            elem = attr + ":";
            if ("object" === typeof attrs[attr]) {
                elem += "{" + make_binding(attrs[attr]) + "}";
            } else {
                elem += attrs[attr];
            }
            elems.push(elem);
        }
        return {"data-bind": elems.join(",")};
    };

    /**
     * generator for column pids
     * @private
     * @return  {String} pid in the form column_{pid}
     */
    pid_for_column = pid_generator("column_");

    /**
     * unwraps template and changes to tags if identifier
     * @private
     * @this {Object} something with a template property
     */
    unwrap_template = function ( ) {
        if (this.template instanceof Function) {
            this.template = this.template();
        }
        if (/^[$A-Z_][$0-9A-Z_]*$/i.test(this.template)) {
            this.template =
                "&lt;!-- ko template:'" + this.template + "' -->&lt;!-- /ko -->";
        }
    };

    // polyfill
    if (!ko.isObservableArray) {
        ko.isObservableArray = function ( o ) {
            return ko.isObservable(o) &amp;&amp; o.push;
        };
    }

    /**
     * @namespace ko.grid
     * @memberof ko
     */
    ko.grid = {
        /**
         * ascending order for sorting
         * @static
         * @memberof ko.grid
         * @member SORT_ASC
         * @default ASC
         */
        SORT_ASC: "ASC"
        /**
         * descending order for sorting
         * @static
         * @memberof ko.grid
         * @member SORT_DSC
         * @default DEC
         */
    ,   SORT_DSC: "DEC"
        /**
         * control column type
         * @static
         * @memberof ko.grid
         * @member TYPE_CONTROL
         * @default control
         */
    ,   TYPE_CONTROL: "control"
        /**
         * text column type
         * @static
         * @memberof ko.grid
         * @member TYPE_TEXT
         * @default text
         */
    ,   TYPE_TEXT: "text"
        /**
         * string column type
         * @static
         * @memberof ko.grid
         * @member TYPE_STRING
         * @default string
         */
    ,   TYPE_STRING: "string"
        /**
         * checkbox column type
         * @static
         * @memberof ko.grid
         * @member TYPE_CHECKBOX
         * @default checkbox
         */
    ,   TYPE_CHECKBOX: "checkbox"
    };

    // ========== TEMPLATES ==========

    /**
     * @namespace ko.grid.templates
     * @memberof ko.grid
     */
    ko.grid.templates = {  };

    /**
     * control template generator
     * @static
     * @memberof ko.grid.templates
     * @function control
     * @return {String} control template
     */
    ko.grid.templates[ko.grid.TYPE_CONTROL] = function ( ) {
        return "";
    };

    /**
     * text template generator - no input, display value only
     * @static
     * @memberof ko.grid.templates
     * @function text
     * @return {String} text template
     */
    ko.grid.templates[ko.grid.TYPE_TEXT] = function ( ) {
        return make_element("span", make_binding({text: "value"}));
    };

    /**
     * string template generator - input as string type
     * @static
     * @memberof ko.grid.templates
     * @function string
     * @return {String} string template
     */
    ko.grid.templates[ko.grid.TYPE_STRING] = function ( ) {
        var attrs = make_binding({value: "value"});
        attrs.type = "text";
        return make_element("input", attrs, false);
    };

    /**
     * checkbox template generator - input as checkbox type
     * @static
     * @memberof ko.grid.templates
     * @function checkbox
     * @return {String} string template
     */
    ko.grid.templates[ko.grid.TYPE_CHECKBOX] = function ( ) {
        var attrs = make_binding({value: "value", checked: "value"});
        attrs.type = "checkbox";
        return make_element("input", attrs, false);
    };

    // ========== DATA MODELS ==========

    /**
     * model for grid data
     * @class DataModel
     * @memberof ko.grid
     * @param {Object} options overridable settings
     * @param {Array&lt;Object|Array>} [options.rows=[ ]] initial dataset
     * @param {Number}  [options.page=1] current page location
     * @param {Number}  [options.pageSize=20] count of items per page
     * @param {Boolean} [options.usejson=true] treat rows as json objects
     *  alternative will expect arrays
     * @param {String}  [options.sortField=null] field to sort by
     * @param {String}  [options.sortOrder={@link ko.grid.SORT_ASC}]
     *  order to sort by
     * @param {Function} [options.onrequest=null] data request callback
     * @param {Function} [options.onaddrow=null] row normalization callback
     * @param {Function} [options.onaddcell=null] cell normalization callback
     * @param {Function} [options.onchange=null] data change callback
     * @param {Function} [options.onbefore=null] data before change callback
     */
    ko.grid.DataModel = function ( options ) {
        var that;

        if (!this) {
            return new ko.grid.DataModel(options);
        }

        that = this;

        $.extend(this, {
            rows: [  ]
        ,   page: 1
        ,   pageSize: 20
        ,   usejson: true
        ,   sortField: null
        ,   sortOrder: ko.grid.SORT_ASC
        ,   onrequest: null
        ,   onadd: null
        ,   onchange: null
        }, options);

        this.mapper = function ( row ) {
            var obj, index, convert;

            obj = row.data();

            convert = function ( val, index ) {
                var selector = obj instanceof Array ? index : index + ":name"
                ,   column = row.column(selector)
                ,   cell = row.cell(row.node(), selector)
                ;

                if (!ko.isObservable(val)) {
                    val = ko.observable(val);
                }

                obj[index] = val;

                if ("function" === typeof that.onchange) {
                    val.subscribe(function ( ) {
                        that.onchange({
                            row: row,
                            cell: cell,
                            column: column
                        });
                    });
                }

                if ("function" === typeof that.onbefore) {
                    val.subscribe(function ( ) {
                        that.onbefore({
                            row: row,
                            cell: cell,
                            column: column
                        });
                    }, null, "beforeChange");
                }

                if ("function" === typeof that.onaddcell) {
                    that.onaddcell.call(that, cell);
                }
            };

            for (index in obj) {
                convert(obj[index], index);
            }

            if ("function" === typeof that.onaddrow) {
                that.onaddrow.call(that, row);
            }

            return obj;
        };

        if (!ko.isObservableArray(that.rows)) {
            // TODO: preserve subscriptions
            that.rows = ko.observableArray(ko.unwrap(this.rows));
        }

        if ("function" === typeof that.onrequest) {
            that.refresh = function ( ) {
                that.onrequest(this, function ( error, rows ) {
                    // TODO: error handler
                    if (error) { return; }
                    if (rows) {
                        that.rows(ko.unwrap(rows));
                    }
                });
            };
        } else {
            that.refresh = function ( ) { };
        }

        [   "page"
        ,   "pageSize"
        ,   "sortField"
        ,   "sortOrder"
        ].forEach(function ( name ) {
            if (!ko.isObservable(that[name])) {
                that[name] = ko.observable(that[name]);
            }

            if ("function" === typeof that.onrequest) {
                that[name].subscribe(that.onrefresh);
            }
        });
    };

    // ========== COLUMN MODELS ==========

    /**
     * base model for grid column
     * @class ColumnModel
     * @memberof ko.grid
     * @param {String|Object} [options]
     *  when object: overridable settings;
     *  when string: fills title
     * @param {String} [options.name] identification value
     * @param {String} [options.title] display name
     * @param {String} [options.type] editor type information
     *  (useful for comboboxes, etc)
     * @param {String} [options.template] cell rendering template
     * @param {Boolean} [options.control] is control column
     */
    ko.grid.ColumnModel = function ( options ) {

        if (!this) {
            return new ko.grid.ColumnModel(options);
        }

        if ("string" === typeof options) {
            this.name = options;
        } else if (options instanceof Object) {
            $.extend(this, options);
        }

        if (this.type === void 0) {
            this.type = ko.grid.TYPE_TEXT;
        }

        if (this.name === void 0) {
            this.name = pid_for_column();
        }

        if (this.title === void 0) {
            this.title = this.name
                .replace(/_/g, " ")
                .replace(/([a-z])([A-Z])/g, "$1 $2");
        }

        if (this.control) {
            this.title = "";
            this.className = (this.className || "") + " control";
            this.orderable = false;
            this.defaultContent = "";
            this.type = ko.grid.TYPE_CONTROL;
        }

        if (this.template === void 0) {
            this.template = ko.grid.templates[this.type] ||
                "&lt;!-- ko template:'" + this.type + "' -->&lt;!-- /ko -->";
        }

        unwrap_template.call(this);
    };

    // ========== SELECTION MODELS ==========

    /**
     * base selection model class
     * @memberof ko.grid
     * @class SelectionModel
     * @param {Object} [options] fine tune controls
     * @param {String} [options.class="active"] classname to apply on select
     * @param {String} [options.modifier="meta"] key to activate modified state
     * @param {Object|Function} [options.selected=ko.observable] selected item
     * @param {Function} [options.onchange=null] called when selection changes
     * @param {Function} [options.onbefore=null] called before selection change
     * @param {Function} [options.onregister] called to register a row
     * @example
     *  new ko.grid.SelectionModel({
     *    onregister: function ( row ) {
     *      $(row.node()).click(this.select.bind(this, row));
     *    }
     *  });
     */
    ko.grid.SelectionModel = function ( options ) {

        if (!this) {
            return new ko.grid.SelectionModel(options);
        }

        $.extend(this, {
            class: "active"
        ,   modifier: "meta"
        ,   selected: ko.observable()
        ,   onchange: null
        ,   onbefore: null
        ,   onregister: function ( row ) {
                $(row.node()).click(this.select.bind(this, row));
            }
        }, options);

        this.modifier = this.modifier + "Key";

        if (!ko.isObservable(this.selected)) {
            this.selected = ko.observable(this.selected);
        }

        if ("function" === typeof this.onchange) {
            this.selected.subscribe(this.onchange);
        }

        if ("function" === typeof this.onbefore) {
            this.selected.subscribe(this.onbefore, null, "beforeChange");
        }

        this.select = function ( ) {
            throw new Error("grid: selection model is abstract");
        };
    };

    /**
     * @class RowSelectionModel
     * @memberof ko.grid
     */
    ko.grid.RowSelectionModel = function ( options ) {
        var last_elem;

        if (!this) {
            return new ko.grid.RowSelectionModel(options);
        }

        ko.grid.SelectionModel.call(this, options);

        this.select = function ( row, evt ) {
            var $row = $(row.node());
            if (this.selected() === row &amp;&amp; evt[this.modifier]) {
                this.selected(null);
                $row.removeClass(this.class);
                last_elem = null;
            } else {
                this.selected(row);
                $row.addClass(this.class);
                if (last_elem) {
                    last_elem.removeClass(this.class);
                }
                last_elem = $row;
            }
        };
    };

    ko.grid.MultiRowSelectionModel = function ( options ) {
        if (!this) {
            return new ko.grid.MultiRowSelectionModel(options);
        }

        options = $.extend({
            selected: ko.observableArray([ ])
        }, options);

        if (!ko.isObservableArray(options.selected)) {
            options.selected = ko.observableArray(ko.unwrap(options.selected));
        }

        ko.grid.SelectionModel.call(this, options);

        this.select = function ( row, evt ) {
            var $row = $(row.node()), sel, sels = this.selected();
            if (evt[this.modifier]) {
                if (~(sels.indexOf(row))) {
                    this.selected.remove(row);
                    $row.removeClass(this.class);
                } else {
                    this.selected.push(row);
                    $row.addClass(this.class);
                }
            } else {
                if (sels.length !== 1 || sels[0] !== row) {
                    for (sel in sels) {
                        $(sels[sel].node()).removeClass(this.class);
                    }
                    this.selected([row]);
                    $row.addClass(this.class);
                } else if (sels[0] === row &amp;&amp; evt[this.modifier]) {
                    this.selected([]);
                    $row.removeClass(this.class);
                }
            }
        };
    };

    // ========== CHILD MODEL ==========

    /**
     * model for child rows
     * @static
     * @memberof ko.grid
     * @class ChildModel
     * @param {Object|String} options fine tune controls or template
     * @param {String} options.template how to render this child
     * @param {String} [options.data] overrides row data for context
     * @param {Function} [options.onbefore] called before child is shown
     * @param {Function} [options.onafter] called after child is shown
     * @param {Object} [options.animate] options for animation, don't if falsey
     */
    ko.grid.ChildModel = function ( options ) {

        if (!(this instanceof ko.grid.ChildModel)) {
            return new ko.grid.ChildModel(options);
        }

        if ("string" === typeof options) {
            options = { template: options };
        }

        $.extend(this, {
            onbefore: null
        ,   onafter: null
        ,   animate: null
        }, options);

        if (!this.template) {
            throw new Error("grid: child model requires template");
        }

        if (this.animate &amp;&amp; this.animate.constructor !== Object) {
            this.animate = { };
        }

        unwrap_template.call(this);

        this.template =
            "&lt;div class='grid_child_wrapper'" +
            (this.animate ? " style='display:none'>" : ">") +
            this.template + "&lt;/div>";
    };

    // ========== KO BINDING ==========

    /**
     * type detection, override to provide custom detection
     * @static
     * @memberof ko.grid
     * @function detect_type
     * @param {Any} item item to detect type of
     * @return {String} type of passed item
     * @example
     *      var old_detect = ko.grid.detect_type;
     *      ko.grid.detect_type = function ( item ) {
     *          if ("MyClass" === item.constructor.name) {
     *              return "mytype";
     *          }
     *          return old_detect(item);
     *      };
     */
    ko.grid.detect_type = function ( item ) {
        switch (item.constructor.name) {
            case "Boolean":
                return ko.grid.TYPE_CHECKBOX;
            case "String":
                return ko.grid.TYPE_STRING;
            default:
                return ko.grid.TYPE_TEXT;
        }
    };

    /**
     * generator for column templates
     * @private
     * @static
     * @memberof ko.grid
     * @function create_column_template
     * @param {Object} settings binding handler settings
     */
    ko.grid.create_column_template = function ( settings ) {
        var data, index;
        settings.columnModels = [ ];

        if (!(data = settings.dataModel.rows()[0])) {
            throw new Error("grid: cannot generate columns with no data");
        }

        if (!(data instanceof Array)) {
            settings.usejson = true;
        }

        for (index in data) {
            settings.columnModels.push(new ko.grid.ColumnModel({
                name: index
            ,   type: (settings.readonly || index.indexOf("_") === 0)
                ? "text"
                : ko.grid.detect_type(ko.unwrap(data[index]))
            }));
        }
    };

    /**
     * factory for row templates
     * @private
     * @static
     * @memberof ko.grid
     * @function create_row_template
     * @param {Object} settings binding handler settings
     * @return {Element} row template
     */
    ko.grid.create_row_template = function ( settings ) {
        var row_template = $("&lt;tr>")
        ,   template
        ,   index
        ,   model
        ;

        if (!settings.columnModels) {
            ko.grid.create_column_template(settings);
        }

        for (index in settings.columnModels) {
            model = settings.columnModels[index];
            if (!(model instanceof ko.grid.ColumnModel)) {
                settings.columnModels[index] = model =
                    new ko.grid.ColumnModel(model);
            }
            // correct data members
            if (settings.dataModel.usejson &amp;&amp; model.data === void 0) {
                model.data = model.name;
            }
            // add convenience members
            model.index = index;
            model.value = (model.data) ? model.name : "$data[" + index + "]";
            // auto detect settings
            if (model.searchable) {
                settings._searchable = true;
            }
            // form cell and unwrap template if necessary
            template = $("&lt;td class=\"type_" +
                model.type + " name_" +
                model.name + " " +
                (model.className || "") + "\">");

            // add model to template
            template.append(
                $("&lt;!-- ko with: {value: " + model.value + ", row: $row} -->"));
            template.append(model.template);
            template.append(
                $("&lt;!-- /ko -->"));
            // add template to row
            row_template.append(template);
        }

        // unwrap from jquery
        row_template = row_template[0];

        // register to anonymous template
        new ko.templateSources.anonymousTemplate(row_template)
            .nodes(row_template);
        // TODO: fix memory leak

        return row_template;
    };

    // TODO: document
    ko.grid.register_children = function ( row, models ) {
        var children = [ ]
        ,   templates = models.map(function ( model ) {
                return model.template;
            });

        row.children = { };

        row.children.shown = row.child.isShown;
        row.children.hidden = function ( ) {
            return !row.children.shown();
        };

        row.children.show = function ( ) {
            if (row.children.hidden()) {
                row.child(templates).show();
                children = [ ];
                row.child().each(function ( index ) {
                    var child, data, model = models[index];

                    children.push(child = this.children[0].children[0]);

                    if (model.onbefore instanceof Function) {
                        data = model.onbefore(child, row);
                    }

                    ko.applyBindings(model.data || data || {
                        row: row
                    ,   data: row.data()
                    }, child);

                    if (model.animate) {
                        $(child).slideDown(model.animate);
                    }

                    if (model.onafter instanceof Function) {
                        model.onafter(child, row);
                    }
                });
            }
        };

        row.children.hide = function ( ) {
            var count = 0
            ,   done = function (  ) {
                    if (count++ === children.length) {
                        row.child.hide();
                    }
                };
            if (row.children.shown()) {
                children.forEach(function ( child, index ) {
                    var model = models[index];

                    if (model.onbefore instanceof Function) {
                        model.onbefore(child, row);
                    }
                    if (model.animate) {
                        model.animate._complete = model.complete;
                        model.animate.complete = function (  ) {
                            if (model.animate._complete instanceof Function) {
                                model.animate._complete.apply(this, arguments);
                            }
                            if (model.onafter instanceof Function) {
                                model.onafter(child, row);
                            }
                            done();
                        };
                        $(child).slideUp(model.animate);
                    } else {
                        if (model.onafter instanceof Function) {
                            model.onafter(child, row);
                        }
                        done();
                    }
                });
                done();
            }
        };
    };

    /**
     * @namespace ko.bindingHandlers
     * @memberof ko
     */

    /**
     * @namespace grid
     * @memberof ko.bindingHandlers
     */
    ko.bindingHandlers.grid = {
        // TODO: document valueAccessor properties
        /**
         * called to initialize grid binding within knockout
         * @memberof ko.bindingHandlers.grid
         * @function init
         * @param {Element} element node holding binding
         * @param {Function} valueAccessor accesses bindings
         * @param {Function} allBindingsAccessor accesses all bindings
         * @param {Object} viewModel data associated to binding
         * @param {Object} bindingContext context associated to binding
         */
        init: function (
                element
            ,   valueAccessor
            // jshint unused: false
            // reason; need last perameter but not these
            ,   allBindingsAccessor
            ,   viewModel
            // jshint unused: true
            ,   bindingContext
        ) {
            var settings, options, table, api;

            settings = valueAccessor() || { };
            settings.options = settings.options || { };
            options = settings.options;

            // settings normalization
            if (!(settings.dataModel instanceof ko.grid.DataModel)) {
                settings.dataModel = new ko.grid.DataModel(settings.dataModel);
            }

            settings._row_template = ko.grid.create_row_template(settings);


            if (settings.childrenModels) {
                settings.childrenModels =
                settings.childrenModels.map(function ( template ) {
                    if (!(template instanceof ko.grid.ChildModel)) {
                        template = new ko.grid.ChildModel(template);
                    }
                    return template;
                });
            }
            // options construction
            options.columns = settings.columnModels;
            options.data = ko.unwrap(settings.dataModel.rows);
            options.serverSide = settings.dataModel.request instanceof Function;
            if (!options.dom) {
                options.dom = (options.allowColumnReorder ? "R" : "") +
                    "ti" + (options.scrollY ? "S" : "p") +
                    (settings._searchable ? "f" : "");
            }

            if (options.serverSide) {
                options.serverData = function ( source, data ) {
                    // TODO: tie into data model
                    console.log(source, data);
                };
            }

            settings._createdRow = options.createdRow;
            options.createdRow = function ( row, src, index ) {
                var $row, _row, ctx;

                $row = $(row);
                _row = this.api().row($row);
                ctx = settings.dataModel.mapper(_row);

                ctx = bindingContext.createChildContext(ctx, settings.as);
                ctx.$row = _row;

                ko.renderTemplate(settings._row_template,
                    ctx, { }, row, "replaceChildren");

                if (settings.childrenModels) {
                    ko.grid.register_children(_row, settings.childrenModels);
                }

                if (settings._createdRow instanceof Function) {
                    settings._createdRow.call(this, row, src, index);
                }

                if (settings.oncreaterow instanceof Function) {
                    settings.oncreaterow.call(this, _row);
                }

                if (settings.selectionModels) {
                    settings.selectionModels.forEach(function ( model ) {
                        model.onregister(_row);
                    });
                }
            };

            table = $(element).dataTable(options);
            api = table.api();

            var before, diff;
            diff = function ( arr1, arr2 ) {
                return arr1.filter(function ( item ) {
                    return !~arr2.indexOf(item);
                });
            };

            settings.dataModel.rows.subscribe(function ( items ) {
                before = items.slice(0);
            }, null, "beforeChange");
            settings.dataModel.rows.subscribe(function ( items ) {
                //var nodes, count;
                var removed = diff(before, items)
                ,   added = diff(items, before)
                ;

                removed.forEach(function ( item ) {
                    api.row(function ( index, data ) {
                        return item === data;
                    }).remove();
                });

                api.rows.add(added);

                api.draw();

            });

            if (settings.api instanceof Function) {
                settings.api(api, table);
            }
        }
    };
});

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ko.grid.ChildModel.html">ChildModel</a></li><li><a href="ko.grid.ColumnModel.html">ColumnModel</a></li><li><a href="ko.grid.DataModel.html">DataModel</a></li><li><a href="ko.grid.RowSelectionModel.html">RowSelectionModel</a></li><li><a href="ko.grid.SelectionModel.html">SelectionModel</a></li></ul><h3>Namespaces</h3><ul><li><a href="ko.html">ko</a></li><li><a href="ko.bindingHandlers.html">bindingHandlers</a></li><li><a href="ko.bindingHandlers.grid.html">grid</a></li><li><a href="ko.grid.html">grid</a></li><li><a href="ko.grid.templates.html">templates</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Tue Jul 14 2015 11:36:26 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
